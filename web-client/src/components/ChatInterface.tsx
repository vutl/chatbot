import { useState, useRef, useEffect } from 'react';
import {
  Box,
  Flex,
  Input,
  IconButton,
  VStack,
  useToast,
  Container,
  Button,
  Text,
  Image,
  Spinner,
} from '@chakra-ui/react';
import { ChatMessage } from './ChatMessage';
import { chatService } from '../services/chatService';
import { ChatMessage as IChatMessage, ChatState } from '../types/chat';
import { v4 as uuidv4 } from 'uuid';

// Tin nh·∫Øn ch√†o m·ª´ng khi ng∆∞·ªùi d√πng v√†o trang
const WELCOME_MESSAGE = "üëã Ch√†o b·∫°n, t√¥i l√† ZenAI - Tr·ª£ l√Ω ch·ª©ng kho√°n t√†i ch√≠nh th√¥ng minh. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n n√†o, ƒë·ª´ng ng·∫°i ƒë·∫∑t c√¢u h·ªèi cho t√¥i nh√© ü•∞";

// Danh s√°ch c√°c tin nh·∫Øn ch·ªù ƒë·ª£i khi ph·∫£n h·ªìi qu√° l√¢u
const WAITING_MESSAGES = [
  "D·ªØ li·ªáu ƒë·ªÉ t√¥i ph√¢n t√≠ch h∆°i nhi·ªÅu, b·∫°n ƒë·ª£i ch√∫t nh√© t√¥i ƒëang ph√¢n t√≠ch s·∫Øp xong r·ªìi",
  "T√¥i ƒëang r√† so√°t l·∫°i th√¥ng tin, tin t·ª©c th·ªã tr∆∞·ªùng li√™n quan, b·∫°n ch·ªù x√≠u nh√©...",
  "ƒêang t·ªïng h·ª£p d·ªØ li·ªáu t·ª´ nhi·ªÅu ngu·ªìn kh√°c nhau, vui l√≤ng ƒë·ª£i trong gi√¢y l√°t...",
  "T√¥i ƒëang ph√¢n t√≠ch k·ªπ l∆∞·ª°ng th√¥ng tin ƒë·ªÉ ƒë∆∞a ra c√¢u tr·∫£ l·ªùi ch√≠nh x√°c nh·∫•t, s·∫Ω xong ngay th√¥i!",
  "ƒêang t√¨m ki·∫øm th√¥ng tin m·ªõi nh·∫•t v·ªÅ ch·ªß ƒë·ªÅ n√†y, b·∫°n ƒë·ª£i m·ªôt ch√∫t nh√©...",
  "C√¢u h·ªèi c·ªßa b·∫°n kh√° ph·ª©c t·∫°p, t√¥i ƒëang t·ªïng h·ª£p th√¥ng tin ƒë·ªÉ tr·∫£ l·ªùi ƒë·∫ßy ƒë·ªß nh·∫•t...",
  "...",
];

// M·ªü r·ªông interface IChatMessage ƒë·ªÉ th√™m thu·ªôc t√≠nh isWaitingMessage
declare module '../types/chat' {
  interface ChatMessage {
    isWaitingMessage?: boolean;
  }
}

export const ChatInterface = () => {
  const [state, setState] = useState<ChatState>({
    sessionId: null,
    messages: [],
    isLoading: false,
    error: null,
  });
  const [inputMessage, setInputMessage] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const welcomeMessageShownRef = useRef<boolean>(false);
  const waitingMessageTimerRef = useRef<NodeJS.Timeout | null>(null);
  const waitingMessageShownRef = useRef<boolean>(false);
  const isLoadingRef = useRef<boolean>(false); // Th√™m ref ƒë·ªÉ theo d√µi tr·∫°ng th√°i loading
  const toast = useToast();

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  // C·∫≠p nh·∫≠t isLoadingRef khi state.isLoading thay ƒë·ªïi
  useEffect(() => {
    isLoadingRef.current = state.isLoading;
    console.log('Loading state changed:', state.isLoading);
  }, [state.isLoading]);

  useEffect(() => {
    // T·∫°o session m·ªõi khi component ƒë∆∞·ª£c mount
    initializeSession();
    
    // Cleanup function ƒë·ªÉ reset ref khi component unmount
    return () => {
      welcomeMessageShownRef.current = false;
      if (waitingMessageTimerRef.current) {
        clearTimeout(waitingMessageTimerRef.current);
      }
    };
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [state.messages]);

  // Th√™m tin nh·∫Øn ch√†o m·ª´ng t·ª´ bot
  const addWelcomeMessage = () => {
    // Ki·ªÉm tra xem welcome message ƒë√£ ƒë∆∞·ª£c hi·ªÉn th·ªã ch∆∞a
    if (welcomeMessageShownRef.current) {
      console.log('Welcome message already shown, skipping...');
      return;
    }
    
    console.log('Adding welcome message...');
    const botMessage: IChatMessage = {
      id: uuidv4(),
      content: WELCOME_MESSAGE,
      role: 'assistant',
      timestamp: new Date(),
    };

    setState(prev => ({
      ...prev,
      messages: [...prev.messages, botMessage],
    }));
    
    // ƒê√°nh d·∫•u l√† ƒë√£ hi·ªÉn th·ªã welcome message
    welcomeMessageShownRef.current = true;
  };

  // Th√™m tin nh·∫Øn ch·ªù ƒë·ª£i khi ph·∫£n h·ªìi qu√° l√¢u
  const addWaitingMessage = () => {
    if (waitingMessageShownRef.current) {
      console.log('Waiting message already shown, skipping...');
      return;
    }
    
    console.log('Adding waiting message...');
    
    // C√°ch 1: C√≥ x√°c su·∫•t kh√¥ng hi·ªÉn th·ªã waiting message
    const shouldShowMessage = Math.random() < 0.7; // 70% x√°c su·∫•t hi·ªÉn th·ªã message
    
    if (!shouldShowMessage) {
      console.log('Randomly decided not to show waiting message');
      return;
    }
    
    // Ch·ªçn ng·∫´u nhi√™n m·ªôt tin nh·∫Øn t·ª´ danh s√°ch
    const randomIndex = Math.floor(Math.random() * WAITING_MESSAGES.length);
    console.log('Selected waiting message index:', randomIndex, 'from total:', WAITING_MESSAGES.length);
    
    const waitingMessage = WAITING_MESSAGES[randomIndex];
    console.log('Selected waiting message:', waitingMessage);
    
    const botMessage: IChatMessage = {
      id: uuidv4(),
      content: waitingMessage,
      role: 'assistant',
      timestamp: new Date(),
      isWaitingMessage: true, // ƒê√°nh d·∫•u ƒë√¢y l√† tin nh·∫Øn ch·ªù ƒë·ª£i
    };

    setState(prev => ({
      ...prev,
      messages: [...prev.messages, botMessage],
    }));
    
    waitingMessageShownRef.current = true;
    console.log('Waiting message shown flag set to true');
  };

  const initializeSession = async () => {
    try {
      setState(prev => ({ ...prev, isLoading: true }));
      const sessionId = await chatService.createSession();
      /* Truy·ªÅn context l√† null ho·∫∑c r·ªóng l√™n th√¨ s·∫Ω s·ª≠ d·ª•ng system promt default tr√™n server l√† tr·ª£ l√Ω ch·ª©ng kho√°n */
      await chatService.updateSystemPrompt(sessionId, "");
      setState(prev => ({
        ...prev,
        sessionId,
        isLoading: false
      }));

      // Hi·ªÉn th·ªã tin nh·∫Øn ch√†o m·ª´ng sau khi kh·ªüi t·∫°o session th√†nh c√¥ng
      // Ch·ªâ g·ªçi n·∫øu ch∆∞a hi·ªÉn th·ªã welcome message
      if (!welcomeMessageShownRef.current) {
        setTimeout(() => {
          addWelcomeMessage();
        }, 500); // Th√™m ƒë·ªô tr·ªÖ nh·ªè ƒë·ªÉ t·∫°o c·∫£m gi√°c t·ª± nhi√™n
      }

    } catch (error) {
      handleError(error);
    }
  };

  // T√°ch logic g·ª≠i tin nh·∫Øn th√†nh m·ªôt h√†m ri√™ng ƒë·ªÉ t√°i s·ª≠ d·ª•ng
  const sendMessage = async (message: string) => {
    if (!message.trim() || !state.sessionId) return;

    const userMessage: IChatMessage = {
      id: uuidv4(),
      content: message,
      role: 'user',
      timestamp: new Date(),
    };

    setState(prev => ({
      ...prev,
      messages: [...prev.messages, userMessage],
      isLoading: true,
      error: null,
    }));
    setInputMessage('');
    
    // Reset tr·∫°ng th√°i tin nh·∫Øn ch·ªù ƒë·ª£i
    waitingMessageShownRef.current = false;
    console.log('Reset waiting message shown flag to false');
    
    // Thi·∫øt l·∫≠p timer ƒë·ªÉ hi·ªÉn th·ªã tin nh·∫Øn ch·ªù ƒë·ª£i sau 5 gi√¢y
    if (waitingMessageTimerRef.current) {
      clearTimeout(waitingMessageTimerRef.current);
      waitingMessageTimerRef.current = null;
    }
    /* T·∫°o bi·∫øn random gi√° tr·ªã t·ª´ 5000 t·ªõi 10000 */
    let rdTime = Math.floor(Math.random() * 5000) + 5000;

    waitingMessageTimerRef.current = setTimeout(() => {
      console.log('Checking if waiting message should be shown...');
      console.log('Current loading state (ref):', isLoadingRef.current);
      
      // S·ª≠ d·ª•ng ref ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i loading hi·ªán t·∫°i
      if (isLoadingRef.current) {
        console.log('Showing waiting message...');
        addWaitingMessage();
      } else {
        console.log('Not showing waiting message because not loading anymore');
      }
    }, rdTime);

    try {
      /* ƒê·ªãnh d·∫°ng response tr·∫£ v·ªÅ : 
      {
    "content": "üìä Gi√° hi·ªán t·∫°i c·ªßa c·ªï phi·∫øu HPG l√† 26.45 VND. üìà\n\nB·∫°n c√≥ c·∫ßn th√¥ng tin th√™m v·ªÅ m√£ HPG kh√¥ng? ZenAI c√≥ th·ªÉ cung c·∫•p ph√¢n t√≠ch chi ti·∫øt ho·∫∑c th√¥ng tin m·ªõi nh·∫•t v·ªÅ c√¥ng ty v√† th·ªã tr∆∞·ªùng.",
    "role": "assistant",
    "timestamp": "2025-02-25T14:45:25.531Z",
    "sessionId": "ee1caeb2-26d7-458f-9a9c-30d86101f946",
    "suggestionQuery": [
        "Ph√¢n t√≠ch k·ªπ thu·∫≠t m√£ HPG trong tu·∫ßn qua",
        "Tin t·ª©c m·ªõi nh·∫•t ·∫£nh h∆∞·ªüng ƒë·∫øn gi√° c·ªï phi·∫øu HPG"
    ]
} */
      const response = await chatService.sendMessage({
        sessionId: state.sessionId,
        message: message,
      });
      
      console.log('API Response:', response);
      
      // X√≥a timer khi ƒë√£ nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi
      if (waitingMessageTimerRef.current) {
        clearTimeout(waitingMessageTimerRef.current);
        waitingMessageTimerRef.current = null;
      }

      // Ki·ªÉm tra response c√≥ ƒë√∫ng c·∫•u tr√∫c kh√¥ng
      if (response && response.content && response.role === 'assistant') {
        const botMessage: IChatMessage = {
          id: uuidv4(),
          content: response.content,
          role: response.role,
          timestamp: new Date(response.timestamp),
          suggestionQueries: response.suggestionQuery || [],
        };

        // L·ªçc b·ªè tin nh·∫Øn ch·ªù ƒë·ª£i (n·∫øu c√≥) tr∆∞·ªõc khi th√™m tin nh·∫Øn m·ªõi
        setState(prev => {
          const filteredMessages = prev.messages.filter(msg => !msg.isWaitingMessage);
          return {
            ...prev,
            messages: [...filteredMessages, botMessage],
            isLoading: false,
          };
        });
        
        // Reset tr·∫°ng th√°i tin nh·∫Øn ch·ªù ƒë·ª£i
        waitingMessageShownRef.current = false;
        console.log('Reset waiting message shown flag to false after response');
      } else {
        console.error('Invalid response structure:', response);
        throw new Error('Invalid response structure from server');
      }
    } catch (error) {
      console.error('Error in sendMessage:', error);
      
      // X√≥a timer khi c√≥ l·ªói
      if (waitingMessageTimerRef.current) {
        clearTimeout(waitingMessageTimerRef.current);
        waitingMessageTimerRef.current = null;
      }
      
      // L·ªçc b·ªè tin nh·∫Øn ch·ªù ƒë·ª£i khi c√≥ l·ªói
      setState(prev => {
        const filteredMessages = prev.messages.filter(msg => !msg.isWaitingMessage);
        return {
          ...prev,
          messages: filteredMessages,
          isLoading: false,
        };
      });
      
      // Reset tr·∫°ng th√°i tin nh·∫Øn ch·ªù ƒë·ª£i
      waitingMessageShownRef.current = false;
      console.log('Reset waiting message shown flag to false after error');
      
      handleError(error);
    }
  };
  
  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n n√∫t g·ª≠i ho·∫∑c Enter
  const handleSendMessage = () => {
    sendMessage(inputMessage);
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng click v√†o g·ª£i √Ω
  const handleSuggestionClick = (suggestion: string) => {
    // ƒê·∫∑t n·ªôi dung g·ª£i √Ω v√†o input (ƒë·ªÉ hi·ªÉn th·ªã cho ng∆∞·ªùi d√πng th·∫•y)
    setInputMessage(suggestion);
    
    // G·ª≠i tin nh·∫Øn ngay l·∫≠p t·ª©c v·ªõi n·ªôi dung suggestion
    // S·ª≠ d·ª•ng setTimeout ƒë·ªÉ ƒë·∫£m b·∫£o UI ƒë∆∞·ª£c c·∫≠p nh·∫≠t tr∆∞·ªõc khi g·ª≠i
    setTimeout(() => {
      sendMessage(suggestion);
    }, 100);
  };

  const handleNewSession = async () => {
    // Reset welcome message flag khi t·∫°o session m·ªõi
    welcomeMessageShownRef.current = false;
    waitingMessageShownRef.current = false;
    
    if (waitingMessageTimerRef.current) {
      clearTimeout(waitingMessageTimerRef.current);
      waitingMessageTimerRef.current = null;
    }
    
    setState(prev => ({
      ...prev,
      messages: [],
      isLoading: true,
      error: null,
    }));
    await initializeSession();
  };

  const handleError = (error: any) => {
    setState(prev => ({ ...prev, isLoading: false }));
    let errorMessage = 'C√≥ l·ªói x·∫£y ra';

    if (error && error.response && error.response.data) {
      // L·∫•y th√¥ng tin l·ªói chi ti·∫øt t·ª´ response
      const responseData = error.response.data;
      if (responseData) {
        if (Array.isArray(responseData.message)) {
          errorMessage = responseData.message.join(', ');
        } else if (typeof responseData.message === 'string') {
          errorMessage = responseData.message;
        } else {
          errorMessage = JSON.stringify(responseData);
        }
      }
    } else if (error instanceof Error) {
      errorMessage = error.message;
    }

    toast({
      title: 'L·ªói',
      description: errorMessage,
      status: 'error',
      duration: 5000,
      isClosable: true,
    });
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const getLastBotMessageIndex = () => {
    for (let i = state.messages.length - 1; i >= 0; i--) {
      if (state.messages[i].role === 'assistant' && !state.messages[i].isWaitingMessage) {
        return i;
      }
    }
    return -1;
  };

  return (
    <Box minH="100vh" bg="gray.50" w="100%">
      <Container
        maxW={{ base: "100%", md: "container.lg" }}
        h="100vh"
        p={0}
        display="flex"
        flexDirection="column"
        bg="white"
      >
        {/* Header */}
        <Box
          p={4}
          borderBottom="1px"
          borderColor="gray.200"
          bg="white"
          position="sticky"
          top={0}
          zIndex={1}
        >
          <Flex align="center" justify="center">
            {/* <Image 
              src="/zenai-icon.png" 
              alt="ZenAI Logo" 
              boxSize={{ base: "30px", sm: "40px" }}
              mr={3}
            /> */}
            <Text
              fontSize={{ base: "lg", sm: "xl" }}
              fontWeight="bold"
              bgGradient="linear(to-r, teal.500, green.500)"
              bgClip="text"
            >
              ZenAI Agent
            </Text>
          </Flex>
        </Box>

        {/* Messages */}
        <VStack
          flex={1}
          overflowY="auto"
          spacing={4}
          p={{ base: 3, sm: 6 }}
          w="100%"
          maxW="100%"
          alignItems="stretch"
          sx={{
            '&::-webkit-scrollbar': {
              width: '4px',
            },
            '&::-webkit-scrollbar-track': {
              width: '6px',
            },
            '&::-webkit-scrollbar-thumb': {
              background: 'gray.200',
              borderRadius: '24px',
            },
          }}
        >
          {state.messages.map((msg, index) => (
            <ChatMessage 
              key={msg.id} 
              message={msg} 
              isLatestBotMessage={!state.isLoading && index === getLastBotMessageIndex()}
              onSuggestionClick={handleSuggestionClick}
            />
          ))}
          <div ref={messagesEndRef} />

          {state.isLoading && (
            <Box
              p={4}
              bg="gray.50"
              borderRadius="lg"
              display="flex"
              alignItems="center"
              gap={3}
              alignSelf="flex-start"
              maxW="70%"
              data-testid="loading-indicator"
            >
              <Spinner size="sm" color="green.500" />
              <Text fontSize="sm" color="gray.600">
                ZenAI ƒëang suy nghƒ©...
              </Text>
            </Box>
          )}
        </VStack>

        {/* Input */}
        <Box
          p={{ base: 3, sm: 6 }}
          borderTop="1px"
          borderColor="gray.200"
          bg="white"
          position="sticky"
          bottom={0}
        >
          <Flex gap={3} maxW="100%">
            <Input
              value={inputMessage}
              onChange={(e) => setInputMessage(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Nh·∫≠p tin nh·∫Øn c·ªßa b·∫°n..."
              size={{ base: "md", sm: "lg" }}
              bg="gray.50"
            />
            <Button
              onClick={handleSendMessage}
              colorScheme="teal"
              size={{ base: "md", sm: "lg" }}
              px={6}
              isLoading={state.isLoading}
            >
              G·ª≠i üí¨
            </Button>
          </Flex>
        </Box>
      </Container>
    </Box>
  );
}; 